@c Copyright (C) 1996-2015 John W. Eaton
@c
@c This file is part of Octave.
@c
@c Octave is free software; you can redistribute it and/or modify it
@c under the terms of the GNU General Public License as published by the
@c Free Software Foundation; either version 3 of the License, or (at
@c your option) any later version.
@c
@c Octave is distributed in the hope that it will be useful, but WITHOUT
@c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
@c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
@c for more details.
@c
@c You should have received a copy of the GNU General Public License
@c along with Octave; see the file COPYING.  If not, see
@c <http://www.gnu.org/licenses/>.

@node Functions and Scripts
@chapter Functions and Scripts
@cindex defining functions
@cindex user-defined functions
@cindex functions, user-defined
@cindex script files

Complicated Octave programs can often be simplified by defining
functions.  Functions can be defined directly on the command line during
interactive Octave sessions, or in external files, and can be called just
like built-in functions.

@menu
* Introduction to Function and Script Files::
* Defining Functions::
* Multiple Return Values::
* Variable-length Argument Lists::
* Ignoring Arguments::
* Variable-length Return Lists::
* Returning from a Function::
* Default Arguments::
* Function Files::
* Script Files::
* Function Handles Anonymous Functions Inline Functions::
* Commands::
* Organization of Functions::
@end menu

@node Introduction to Function and Script Files
@section Introduction to Function and Script Files

There are seven different things covered in this section.
@enumerate
@item
Typing in a function at the command prompt.

@item
Storing a group of commands in a file --- called a script file.

@item
Storing a function in a file---called a function file.

@item
Subfunctions in function files.

@item
Multiple functions in one script file.

@item
Private functions.

@item
Nested functions.
@end enumerate

Both function files and script files end with an extension of .m, for
@sc{matlab} compatibility.  If you want more than one independent
functions in a file, it must be a script file (@pxref{Script Files}),
and to use these functions you must execute the script file before you
can use the functions that are in the script file.

@node Defining Functions
@section Defining Functions
@cindex @code{function} statement
@cindex @code{endfunction} statement

In its simplest form, the definition of a function named @var{name}
looks like this:

@example
@group
function @var{name}
  @var{body}
endfunction
@end group
@end example

@noindent
A valid function name is like a valid variable name: a sequence of
letters, digits and underscores, not starting with a digit.  Functions
share the same pool of names as variables.

The function @var{body} consists of Octave statements.  It is the
most important part of the definition, because it says what the function
should actually @emph{do}.

For example, here is a function that, when executed, will ring the bell
on your terminal (assuming that it is possible to do so):

@example
@group
function wakeup
  printf ("\a");
endfunction
@end group
@end example

The @code{printf} statement (@pxref{Input and Output}) simply tells
Octave to print the string @qcode{"@xbackslashchar{}a"}.  The special character
@samp{\a} stands for the alert character (ASCII 7).  @xref{Strings}.

Once this function is defined, you can ask Octave to evaluate it by
typing the name of the function.

Normally, you will want to pass some information to the functions you
define.  The syntax for passing parameters to a function in Octave is

@example
@group
function @var{name} (@var{arg-list})
  @var{body}
endfunction
@end group
@end example

@noindent
where @var{arg-list} is a comma-separated list of the function's
arguments.  When the function is called, the argument names are used to
hold the argument values given in the call.  The list of arguments may
be empty, in which case this form is equivalent to the one shown above.

To print a message along with ringing the bell, you might modify the
@code{wakeup} to look like this:

@example
@group
function wakeup (message)
  printf ("\a%s\n", message);
endfunction
@end group
@end example

Calling this function using a statement like this

@example
wakeup ("Rise and shine!");
@end example

@noindent
will cause Octave to ring your terminal's bell and print the message
@samp{Rise and shine!}, followed by a newline character (the @samp{\n}
in the first argument to the @code{printf} statement).

In most cases, you will also want to get some information back from the
functions you define.  Here is the syntax for writing a function that
returns a single value:

@example
@group
function @var{ret-var} = @var{name} (@var{arg-list})
  @var{body}
endfunction
@end group
@end example

@noindent
The symbol @var{ret-var} is the name of the variable that will hold the
value to be returned by the function.  This variable must be defined
before the end of the function body in order for the function to return
a value.

Variables used in the body of a function are local to the
function.  Variables named in @var{arg-list} and @var{ret-var} are also
local to the function.  @xref{Global Variables}, for information about
how to access global variables inside a function.

For example, here is a function that computes the average of the
elements of a vector:

@example
@group
function retval = avg (v)
  retval = sum (v) / length (v);
endfunction
@end group
@end example

If we had written @code{avg} like this instead,

@example
@group
function retval = avg (v)
  if (isvector (v))
    retval = sum (v) / length (v);
  endif
endfunction
@end group
@end example

@noindent
and then called the function with a matrix instead of a vector as the
argument, Octave would have printed an error message like this:

@example
@group
error: value on right hand side of assignment is undefined
@end group
@end example

@noindent
because the body of the @code{if} statement was never executed, and
@code{retval} was never defined.  To prevent obscure errors like this,
it is a good idea to always make sure that the return variables will
always have values, and to produce meaningful error messages when
problems are encountered.  For example, @code{avg} could have been
written like this:

@example
@group
function retval = avg (v)
  retval = 0;
  if (isvector (v))
    retval = sum (v) / length (v);
  else
    error ("avg: expecting vector argument");
  endif
endfunction
@end group
@end example

There is still one additional problem with this function.  What if it is
called without an argument?  Without additional error checking, Octave
will probably print an error message that won't really help you track
down the source of the error.  To allow you to catch errors like this,
Octave provides each function with an automatic variable called
@code{nargin}.  Each time a function is called, @code{nargin} is
automatically initialized to the number of arguments that have actually
been passed to the function.  For example, we might rewrite the
@code{avg} function like this:

@example
@group
function retval = avg (v)
  retval = 0;
  if (nargin != 1)
    usage ("avg (vector)");
  endif
  if (isvector (v))
    retval = sum (v) / length (v);
  else
    error ("avg: expecting vector argument");
  endif
endfunction
@end group
@end example

Although Octave does not automatically report an error if you call a
function with more arguments than expected, doing so probably indicates
that something is wrong.  Octave also does not automatically report an
error if a function is called with too few arguments, but any attempt to
use a variable that has not been given a value will result in an error.
To avoid such problems and to provide useful messages, we check for both
possibilities and issue our own error message.

@DOCSTRING(nargin)

@DOCSTRING(inputname)

@DOCSTRING(silent_functions)

@node Multiple Return Values
@section Multiple Return Values

Unlike many other computer languages, Octave allows you to define
functions that return more than one value.  The syntax for defining
functions that return multiple values is

@example
@group
function [@var{ret-list}] = @var{name} (@var{arg-list})
  @var{body}
endfunction
@end group
@end example

@noindent
where @var{name}, @var{arg-list}, and @var{body} have the same meaning
as before, and @var{ret-list} is a comma-separated list of variable
names that will hold the values returned from the function.  The list of
return values must have at least one element.  If @var{ret-list} has
only one element, this form of the @code{function} statement is
equivalent to the form described in the previous section.

Here is an example of a function that returns two values, the maximum
element of a vector and the index of its first occurrence in the vector.

@example
@group
function [max, idx] = vmax (v)
  idx = 1;
  max = v (idx);
  for i = 2:length (v)
    if (v (i) > max)
      max = v (i);
      idx = i;
    endif
  endfor
endfunction
@end group
@end example

In this particular case, the two values could have been returned as
elements of a single array, but that is not always possible or
convenient.  The values to be returned may not have compatible
dimensions, and it is often desirable to give the individual return
values distinct names.

It is possible to use the @code{nthargout} function to obtain only some
of the return values or several at once in a cell array.
@xref{Cell Array Objects}.

@DOCSTRING(nthargout)

In addition to setting @code{nargin} each time a function is called,
Octave also automatically initializes @code{nargout} to the number of
values that are expected to be returned.  This allows you to write
functions that behave differently depending on the number of values that
the user of the function has requested.  The implicit assignment to the
built-in variable @code{ans} does not figure in the count of output
arguments, so the value of @code{nargout} may be zero.

The @code{svd} and @code{lu} functions are examples of built-in
functions that behave differently depending on the value of
@code{nargout}.

It is possible to write functions that only set some return values.  For
example, calling the function

@example
@group
function [x, y, z] = f ()
  x = 1;
  z = 2;
endfunction
@end group
@end example

@noindent
as

@example
[a, b, c] = f ()
@end example

@noindent
produces:

@example
@group
a = 1

b = [](0x0)

c = 2
@end group
@end example

@noindent
along with a warning.

@DOCSTRING(nargout)

It is good practice at the head of a function to verify that it has been called
correctly.  In Octave the following idiom is seen frequently

@example
@group
if (nargin < min_#_inputs || nargin > max_#_inputs)
  print_usage ();
endif
@end group
@end example

@noindent
which stops the function execution and prints a message about the correct
way to call the function whenever the number of inputs is wrong.

For compatibility with @sc{matlab}, @code{narginchk} and @code{nargoutchk} are
available which provide similar error checking.

@DOCSTRING(narginchk)

@DOCSTRING(nargoutchk)

Besides the number of arguments, inputs can be checked for various properties.
@code{validatestring} is used for string arguments and
@code{validateattributes} for numeric arguments.

@DOCSTRING(validatestring)

@DOCSTRING(validateattributes)

If none of the preceding functions is sufficient there is also the class
@code{inputParser} which can perform extremely complex input checking for
functions.

@DOCSTRING(inputParser)

@anchor{XREFvarargin} @anchor{XREFvarargout}
@node Variable-length Argument Lists
@section Variable-length Argument Lists
@cindex variable-length argument lists
@cindex @code{varargin}

Sometimes the number of input arguments is not known when the function
is defined.  As an example think of a function that returns the smallest
of all its input arguments.  For example:

@example
@group
a = smallest (1, 2, 3);
b = smallest (1, 2, 3, 4);
@end group
@end example

@noindent
In this example both @code{a} and @code{b} would be 1.  One way to write
the @code{smallest} function is

@example
@group
function val = smallest (arg1, arg2, arg3, arg4, arg5)
  @var{body}
endfunction
@end group
@end example

@noindent
and then use the value of @code{nargin} to determine which of the input
arguments should be considered.  The problem with this approach is
that it can only handle a limited number of input arguments.

If the special parameter name @code{varargin} appears at the end of a
function parameter list it indicates that the function takes a variable
number of input arguments.  Using @code{varargin} the function
looks like this

@example
@group
function val = smallest (varargin)
  @var{body}
endfunction
@end group
@end example

@noindent
In the function body the input arguments can be accessed through the
variable @code{varargin}.  This variable is a cell array containing
all the input arguments.  @xref{Cell Arrays}, for details on working
with cell arrays.  The @code{smallest} function can now be defined
like this

@example
@group
function val = smallest (varargin)
  val = min ([varargin@{:@}]);
endfunction
@end group
@end example

@noindent
This implementation handles any number of input arguments, but it's also
a very simple solution to the problem.

A slightly more complex example of @code{varargin} is a function
@code{print_arguments} that prints all input arguments.  Such a function
can be defined like this

@example
@group
function print_arguments (varargin)
  for i = 1:length (varargin)
    printf ("Input argument %d: ", i);
    disp (varargin@{i@});
  endfor
endfunction
@end group
@end example

@noindent
This function produces output like this

@example
@group
print_arguments (1, "two", 3);
     @print{} Input argument 1:  1
     @print{} Input argument 2: two
     @print{} Input argument 3:  3
@end group
@end example

@DOCSTRING(parseparams)

@node Ignoring Arguments
@section Ignoring Arguments

In the formal argument list, it is possible to use the dummy placeholder
@code{~} instead of a name.  This indicates that the corresponding argument
value should be ignored and not stored to any variable.

@example
@group
function val = pick2nd (~, arg2)
  val = arg2;
endfunction
@end group
@end example

The value of @code{nargin} is not affected by using this declaration.

Return arguments can also be ignored using the same syntax.  Functions may
take advantage of ignored outputs to reduce the number of calculations
performed.  To do so, use the @code{isargout} function to query whether the
output argument is wanted.  For example:

@example
@group
function [out1, out2] = long_function (x, y, z)
  if (isargout (1))
    ## Long calculation
    @dots{}
    out1 = result;
  endif
  @dots{}
endfunction
@end group
@end example

@DOCSTRING(isargout)

@node Variable-length Return Lists
@section Variable-length Return Lists
@cindex variable-length return lists
@cindex @code{varargout}

It is possible to return a variable number of output arguments from a
function using a syntax that's similar to the one used with the
special @code{varargin} parameter name.  To let a function return a
variable number of output arguments the special output parameter name
@code{varargout} is used.  As with @code{varargin}, @code{varargout} is
a cell array that will contain the requested output arguments.

As an example the following function sets the first output argument to
1, the second to 2, and so on.

@example
@group
function varargout = one_to_n ()
  for i = 1:nargout
    varargout@{i@} = i;
  endfor
endfunction
@end group
@end example

@noindent
When called this function returns values like this

@example
@group
[a, b, c] = one_to_n ()
     @result{} a =  1
     @result{} b =  2
     @result{} c =  3
@end group
@end example

If @code{varargin} (@code{varargout}) does not appear as the last
element of the input (output) parameter list, then it is not special,
and is handled the same as any other parameter name.

@DOCSTRING(deal)

@node Returning from a Function
@section Returning from a Function

The body of a user-defined function can contain a @code{return} statement.
This statement returns control to the rest of the Octave program.  It
looks like this:

@example
return
@end example

Unlike the @code{return} statement in C, Octave's @code{return}
statement cannot be used to return a value from a function.  Instead,
you must assign values to the list of return variables that are part of
the @code{function} statement.  The @code{return} statement simply makes
it easier to exit a function from a deeply nested loop or conditional
statement.

Here is an example of a function that checks to see if any elements of a
vector are nonzero.

@example
@group
function retval = any_nonzero (v)
  retval = 0;
  for i = 1:length (v)
    if (v (i) != 0)
      retval = 1;
      return;
    endif
  endfor
  printf ("no nonzero elements found\n");
endfunction
@end group
@end example

Note that this function could not have been written using the
@code{break} statement to exit the loop once a nonzero value is found
without adding extra logic to avoid printing the message if the vector
does contain a nonzero element.

@deftypefn {Keyword} {} return
When Octave encounters the keyword @code{return} inside a function or
script, it returns control to the caller immediately.  At the top level,
the return statement is ignored.  A @code{return} statement is assumed
at the end of every function definition.
@end deftypefn

@node Default Arguments
@section Default Arguments
@cindex default arguments

Since Octave supports variable number of input arguments, it is very useful
to assign default values to some input arguments.  When an input argument
is declared in the argument list it is possible to assign a default
value to the argument like this

@example
@group
function @var{name} (@var{arg1} = @var{val1}, @dots{})
  @var{body}
endfunction
@end group
@end example

@noindent
If no value is assigned to @var{arg1} by the user, it will have the
value @var{val1}.

As an example, the following function implements a variant of the classic
``Hello, World'' program.

@example
@group
function hello (who = "World")
  printf ("Hello, %s!\n", who);
endfunction
@end group
@end example

@noindent
When called without an input argument the function prints the following

@example
@group
hello ();
     @print{} Hello, World!
@end group
@end example

@noindent
and when it's called with an input argument it prints the following

@example
@group
hello ("Beautiful World of Free Software");
     @print{} Hello, Beautiful World of Free Software!
@end group
@end example

Sometimes it is useful to explicitly tell Octave to use the default value
of an input argument.  This can be done writing a @samp{:} as the value
of the input argument when calling the function.

@example
@group
hello (:);
     @print{} Hello, World!
@end group
@end example

@node Function Files
@section Function Files
@cindex function file

Except for simple one-shot programs, it is not practical to have to
define all the functions you need each time you need them.  Instead, you
will normally want to save them in a file so that you can easily edit
them, and save them for use at a later time.

Octave does not require you to load function definitions from files
before using them.  You simply need to put the function definitions in a
place where Octave can find them.

When Octave encounters an identifier that is undefined, it first looks
for variables or functions that are already compiled and currently
listed in its symbol table.  If it fails to find a definition there, it
searches a list of directories (the @dfn{path}) for files ending in
@file{.m} that have the same base name as the undefined
identifier.@footnote{The @samp{.m} suffix was chosen for compatibility
with @sc{matlab}.}  Once Octave finds a file with a name that matches,
the contents of the file are read.  If it defines a @emph{single}
function, it is compiled and executed.  @xref{Script Files}, for more
information about how you can define more than one function in a single
file.

When Octave defines a function from a function file, it saves the full
name of the file it read and the time stamp on the file.  If the time
stamp on the file changes, Octave may reload the file.  When Octave is
running interactively, time stamp checking normally happens at most once
each time Octave prints the prompt.  Searching for new function
definitions also occurs if the current working directory changes.

Checking the time stamp allows you to edit the definition of a function
while Octave is running, and automatically use the new function
definition without having to restart your Octave session.

To avoid degrading performance unnecessarily by checking the time stamps
on functions that are not likely to change, Octave assumes that function
files in the directory tree
@file{@var{octave-home}/share/octave/@var{version}/m}
will not change, so it doesn't have to check their time stamps every time the
functions defined in those files are used.  This is normally a very good
assumption and provides a significant improvement in performance for the
function files that are distributed with Octave.

If you know that your own function files will not change while you are
running Octave, you can improve performance by calling
@code{ignore_function_time_stamp ("all")}, so that Octave will
ignore the time stamps for all function files.  Passing
@qcode{"system"} to this function resets the default behavior.

@c FIXME -- note about time stamps on files in NFS environments?

@DOCSTRING(edit)

@DOCSTRING(mfilename)

@DOCSTRING(ignore_function_time_stamp)

@menu
* Manipulating the Load Path::
* Subfunctions::
* Private Functions::
* Nested Functions::
* Overloading and Autoloading::
* Function Locking::
* Function Precedence::
@end menu

@node Manipulating the Load Path
@subsection Manipulating the Load Path

When a function is called, Octave searches a list of directories for
a file that contains the function declaration.  This list of directories
is known as the load path.  By default the load path contains
a list of directories distributed with Octave plus the current
working directory.  To see your current load path call the @code{path}
function without any input or output arguments.

It is possible to add or remove directories to or from the load path
using @code{addpath} and @code{rmpath}.  As an example, the following
code adds @samp{~/Octave} to the load path.

@example
addpath ("~/Octave")
@end example

@noindent
After this the directory @samp{~/Octave} will be searched for functions.

@DOCSTRING(addpath)

@DOCSTRING(genpath)

@DOCSTRING(rmpath)

@DOCSTRING(savepath)

@DOCSTRING(path)

@DOCSTRING(pathdef)

@DOCSTRING(pathsep)

@DOCSTRING(rehash)

@DOCSTRING(file_in_loadpath)

@DOCSTRING(restoredefaultpath)

@DOCSTRING(command_line_path)

@DOCSTRING(dir_in_loadpath)

@node Subfunctions
@subsection Subfunctions

A function file may contain secondary functions called
@dfn{subfunctions}.  These secondary functions are only visible to the
other functions in the same function file.  For example, a file
@file{f.m} containing

@example
@group
function f ()
  printf ("in f, calling g\n");
  g ()
endfunction
function g ()
  printf ("in g, calling h\n");
  h ()
endfunction
function h ()
  printf ("in h\n")
endfunction
@end group
@end example

@noindent
defines a main function @code{f} and two subfunctions.  The
subfunctions @code{g} and @code{h} may only be called from the main
function @code{f} or from the other subfunctions, but not from outside
the file @file{f.m}.

@node Private Functions
@subsection Private Functions

In many cases one function needs to access one or more helper
functions.  If the helper function is limited to the scope of a single
function, then subfunctions as discussed above might be used.  However,
if a single helper function is used by more than one function, then
this is no longer possible.  In this case the helper functions might
be placed in a subdirectory, called "private", of the directory in which
the functions needing access to this helper function are found.

As a simple example, consider a function @code{func1}, that calls a helper
function @code{func2} to do much of the work.  For example:

@example
@group
function y = func1 (x)
  y = func2 (x);
endfunction
@end group
@end example

@noindent
Then if the path to @code{func1} is @code{<directory>/func1.m}, and if
@code{func2} is found in the directory @code{<directory>/private/func2.m},
then @code{func2} is only available for use of the functions, like
@code{func1}, that are found in @code{<directory>}.

@node Nested Functions
@subsection Nested Functions

Nested functions are similar to subfunctions in that only the main function is
visible outside the file.  However, they also allow for child functions to
access the local variables in their parent function.  This shared access mimics
using a global variable to share information --- but a global variable which is
not visible to the rest of Octave.  As a programming strategy, sharing data
this way can create code which is difficult to maintain.  It is recommended to
use subfunctions in place of nested functions when possible.

As a simple example, consider a parent function @code{foo}, that calls a nested
child function @code{bar}, with a shared variable @var{x}.

@example
@group
function y = foo ()
  x = 10;
  bar ();
  y = x;

  function bar ()
    x = 20;
  endfunction
endfunction

foo ()
 @result{} 20
@end group
@end example

@noindent
Notice that there is no special syntax for sharing @var{x}.  This can lead to
problems with accidental variable sharing between a parent function and its
child.  While normally variables are inherited, child function parameters and
return values are local to the child function.

Now consider the function @code{foobar} that uses variables @var{x} and
@var{y}.  @code{foobar} calls a nested function @code{foo} which takes
@var{x} as a parameter and returns @var{y}.  @code{foo} then calls @code{bat}
which does some computation.

@example
@group
function z = foobar ()
  x = 0;
  y = 0;
  z = foo (5);
  z += x + y;

  function y = foo (x)
    y = x + bat ();

    function z = bat ()
      z = x;
    endfunction
  endfunction
endfunction

foobar ()
    @result{} 10
@end group
@end example

@noindent
It is important to note that the @var{x} and @var{y} in @code{foobar} remain
zero, as in @code{foo} they are a return value and parameter respectively.  The
@var{x} in @code{bat} refers to the @var{x} in @code{foo}.

Variable inheritance leads to a problem for @code{eval} and scripts.  If a
new variable is created in a parent function, it is not clear what should happen
in nested child functions.  For example, consider a parent function @code{foo}
with a nested child function @code{bar}:

@example
@group
function y = foo (to_eval)
  bar ();
  eval (to_eval);

  function bar ()
    eval ("x = 100;");
    eval ("y = x;");
  endfunction
endfunction

foo ("x = 5;")
    @result{} error: can not add variable "x" to a static workspace

foo ("y = 10;")
    @result{} 10

foo ("")
    @result{} 100
@end group
@end example

@noindent
The parent function @code{foo} is unable to create a new variable
@var{x}, but the child function @code{bar} was successful.  Furthermore, even
in an @code{eval} statement @var{y} in @code{bar} is the same @var{y} as in its
parent function @code{foo}.  The use of @code{eval} in conjunction with nested
functions is best avoided.

As with subfunctions, only the first nested function in a file may be called
from the outside.  Inside a function the rules are more complicated.  In
general a nested function may call:

@enumerate 0
@item
Globally visible functions

@item
Any function that the nested function's parent can call

@item
Sibling functions (functions that have the same parents)

@item
Direct children

@end enumerate

As a complex example consider a parent function @code{ex_top} with two
child functions, @code{ex_a} and @code{ex_b}.  In addition, @code{ex_a} has two
more child functions, @code{ex_aa} and @code{ex_ab}.  For example:

@example
function ex_top ()
  ## Can call: ex_top, ex_a, and ex_b
  ## Can NOT call: ex_aa and ex_ab

  function ex_a ()
    ## Call call everything

    function ex_aa ()
      ## Can call everything
    endfunction

    function ex_ab ()
      ## Can call everything
    endfunction
  endfunction

  function ex_b ()
    ## Can call: ex_top, ex_a, and ex_b
    ## Can NOT call: ex_aa and ex_ab
  endfunction
endfunction
@end example

@node Overloading and Autoloading
@subsection Overloading and Autoloading

Functions can be overloaded to work with different input arguments.  For
example, the operator '+' has been overloaded in Octave to work with single,
double, uint8, int32, and many other arguments.  The preferred way to overload
functions is through classes and object oriented programming
(@pxref{Function Overloading}).  Occasionally, however, one needs to undo
user overloading and call the default function associated with a specific
type.  The @code{builtin} function exists for this purpose.

@DOCSTRING(builtin)

A single dynamically linked file might define several
functions.  However, as Octave searches for functions based on the
functions filename, Octave needs a manner in which to find each of the
functions in the dynamically linked file.  On operating systems that
support symbolic links, it is possible to create a symbolic link to the
original file for each of the functions which it contains.

However, there is at least one well known operating system that doesn't
support symbolic links.  Making copies of the original file for each of
the functions is undesirable as it increases the
amount of disk space used by Octave.  Instead Octave supplies the
@code{autoload} function, that permits the user to define in which
file a certain function will be found.

@DOCSTRING(autoload)

@node Function Locking
@subsection Function Locking

It is sometime desirable to lock a function into memory with the
@code{mlock} function.  This is typically used for dynamically linked
functions in Oct-files or mex-files that contain some initialization,
and it is desirable that calling @code{clear} does not remove this
initialization.

As an example,

@example
@group
function my_function ()
  mlock ();
  @dots{}
@end group
@end example

@noindent
prevents @code{my_function} from being removed from memory after it is
called, even if @code{clear} is called.  It is possible to determine if
a function is locked into memory with the @code{mislocked}, and to unlock
a function with @code{munlock}, which the following illustrates.

@example
@group
my_function ();
mislocked ("my_function")
@result{} ans = 1
munlock ("my_function");
mislocked ("my_function")
@result{} ans = 0
@end group
@end example

A common use of @code{mlock} is to prevent persistent variables from
being removed from memory, as the following example shows:

@example
@group
function count_calls ()
  mlock ();
  persistent calls = 0;
  printf ("'count_calls' has been called %d times\n",
          ++calls);
endfunction

count_calls ();
@print{} 'count_calls' has been called 1 times

clear count_calls
count_calls ();
@print{} 'count_calls' has been called 2 times
@end group
@end example

@code{mlock} might equally be used to prevent changes to a function from having
effect in Octave, though a similar effect can be had with the
@code{ignore_function_time_stamp} function.

@DOCSTRING(mlock)

@DOCSTRING(munlock)

@DOCSTRING(mislocked)

@node Function Precedence
@subsection Function Precedence

Given the numerous different ways that Octave can define a function, it
is possible and even likely that multiple versions of a function, might be
defined within a particular scope.  The precedence of which function will be
used within a particular scope is given by

@enumerate 1
@item Subfunction
A subfunction with the required function name in the given scope.

@item Private function
A function defined within a private directory of the directory
which contains the current function.

@item Class constructor
A function that constructs a user class as defined in chapter
@ref{Object Oriented Programming}.

@item Class method
An overloaded function of a class as in chapter
@ref{Object Oriented Programming}.

@item Command-line Function
A function that has been defined on the command-line.

@item Autoload function
A function that is marked as autoloaded with @xref{XREFautoload,,autoload}.

@item A Function on the Path
A function that can be found on the users load-path.  There can also be
Oct-file, mex-file or m-file versions of this function and the precedence
between these versions are in that order.

@item Built-in function
A function that is a part of core Octave such as @code{numel}, @code{size},
etc.
@end enumerate

@node Script Files
@section Script Files

A script file is a file containing (almost) any sequence of Octave
commands.  It is read and evaluated just as if you had typed each
command at the Octave prompt, and provides a convenient way to perform a
sequence of commands that do not logically belong inside a function.

Unlike a function file, a script file must @emph{not} begin with the
keyword @code{function}.  If it does, Octave will assume that it is a
function file, and that it defines a single function that should be
evaluated as soon as it is defined.

A script file also differs from a function file in that the variables
named in a script file are not local variables, but are in the same
scope as the other variables that are visible on the command line.

Even though a script file may not begin with the @code{function}
keyword, it is possible to define more than one function in a single
script file and load (but not execute) all of them at once.  To do
this, the first token in the file (ignoring comments and other white
space) must be something other than @code{function}.  If you have no
other statements to evaluate, you can use a statement that has no
effect, like this:

@example
@group
# Prevent Octave from thinking that this
# is a function file:

1;

# Define function one:

function one ()
  @dots{}
@end group
@end example

To have Octave read and compile these functions into an internal form,
you need to make sure that the file is in Octave's load path
(accessible through the @code{path} function), then simply type the
base name of the file that contains the commands.  (Octave uses the
same rules to search for script files as it does to search for
function files.)

If the first token in a file (ignoring comments) is @code{function},
Octave will compile the function and try to execute it, printing a
message warning about any non-whitespace characters that appear after
the function definition.

Note that Octave does not try to look up the definition of any identifier
until it needs to evaluate it.  This means that Octave will compile the
following statements if they appear in a script file, or are typed at
the command line,

@example
@group
# not a function file:
1;
function foo ()
  do_something ();
endfunction
function do_something ()
  do_something_else ();
endfunction
@end group
@end example

@noindent
even though the function @code{do_something} is not defined before it is
referenced in the function @code{foo}.  This is not an error because
Octave does not need to resolve all symbols that are referenced by a
function until the function is actually evaluated.

Since Octave doesn't look for definitions until they are needed, the
following code will always print @samp{bar = 3} whether it is typed
directly on the command line, read from a script file, or is part of a
function body, even if there is a function or script file called
@file{bar.m} in Octave's path.

@example
@group
eval ("bar = 3");
bar
@end group
@end example

Code like this appearing within a function body could fool Octave if
definitions were resolved as the function was being compiled.  It would
be virtually impossible to make Octave clever enough to evaluate this
code in a consistent fashion.  The parser would have to be able to
perform the call to @code{eval} at compile time, and that would be
impossible unless all the references in the string to be evaluated could
also be resolved, and requiring that would be too restrictive (the
string might come from user input, or depend on things that are not
known until the function is evaluated).

Although Octave normally executes commands from script files that have
the name @file{@var{file}.m}, you can use the function @code{source} to
execute commands from any file.

@DOCSTRING(source)

@node Function Handles Anonymous Functions Inline Functions
@section Function Handles, Anonymous Functions, Inline Functions
@cindex handle, function handles
@cindex anonymous functions
@cindex inline, inline functions

It can be very convenient store a function in a variable so that it
can be passed to a different function.  For example, a function that
performs numerical minimization needs access to the function that
should be minimized.

@menu
* Function Handles::
* Anonymous Functions::
* Inline Functions::
@end menu

@node Function Handles
@subsection Function Handles

A function handle is a pointer to another function and is defined with
the syntax

@example
@@@var{function-name}
@end example

@noindent
For example,

@example
f = @@sin;
@end example

@noindent
creates a function handle called @code{f} that refers to the
function @code{sin}.

Function handles are used to call other functions indirectly, or to pass
a function as an argument to another function like @code{quad} or
@code{fsolve}.  For example:

@example
@group
f = @@sin;
quad (f, 0, pi)
    @result{} 2
@end group
@end example

You may use @code{feval} to call a function using function handle, or
simply write the name of the function handle followed by an argument
list.  If there are no arguments, you must use an empty argument list
@samp{()}.  For example:

@example
@group
f = @@sin;
feval (f, pi/4)
    @result{} 0.70711
f (pi/4)
    @result{} 0.70711
@end group
@end example

@DOCSTRING(is_function_handle)

@DOCSTRING(functions)

@DOCSTRING(func2str)

@DOCSTRING(str2func)

@node Anonymous Functions
@subsection Anonymous Functions

Anonymous functions are defined using the syntax

@example
@@(@var{argument-list}) @var{expression}
@end example

@noindent
Any variables that are not found in the argument list are inherited from
the enclosing scope.  Anonymous functions are useful for creating simple
unnamed functions from expressions or for wrapping calls to other
functions to adapt them for use by functions like @code{quad}.  For
example,

@example
@group
f = @@(x) x.^2;
quad (f, 0, 10)
    @result{} 333.33
@end group
@end example

@noindent
creates a simple unnamed function from the expression @code{x.^2} and
passes it to @code{quad},

@example
@group
quad (@@(x) sin (x), 0, pi)
    @result{} 2
@end group
@end example

@noindent
wraps another function, and

@example
@group
a = 1;
b = 2;
quad (@@(x) betainc (x, a, b), 0, 0.4)
    @result{} 0.13867
@end group
@end example

@noindent
adapts a function with several parameters to the form required by
@code{quad}.  In this example, the values of @var{a} and @var{b} that
are passed to @code{betainc} are inherited from the current
environment.

Note that for performance reasons it is better to use handles to existing
Octave functions, rather than to define anonymous functions which wrap an
existing function.  The integration of @code{sin (x)} is 5X faster if the code
is written as

@example
quad (@@sin, 0, pi)
@end example

@noindent
rather than using the anonymous function @code{@@(x) sin (x)}.  There are many
operators which have functional equivalents that may be better choices than an
anonymous function.  Instead of writing

@example
f = @@(x, y) x + y
@end example

@noindent
this should be coded as

@example
f = @@plus
@end example

@xref{Operator Overloading}, for a list of operators which also have a
functional form.

@node Inline Functions
@subsection Inline Functions

An inline function is created from a string containing the function
body using the @code{inline} function.  The following code defines the
function @math{f(x) = x^2 + 2}.

@example
f = inline ("x^2 + 2");
@end example

@noindent
After this it is possible to evaluate @math{f} at any @math{x} by
writing @code{f(x)}.

@strong{Caution}: @sc{matlab} has begun the process of deprecating inline
functions.  At some point in the future support will be dropped and eventually
Octave will follow @sc{matlab} and also remove inline functions.  Use anonymous
functions in all new code.

@DOCSTRING(inline)

@DOCSTRING(argnames)

@DOCSTRING(formula)

@DOCSTRING(symvar)

@node Commands
@section Commands

Commands are a special class of functions that only accept string
input arguments.  A command can be called as an ordinary function, but
it can also be called without the parentheses.  For example,

@example
my_command hello world
@end example

@noindent
is equivalent to

@example
my_command ("hello", "world")
@end example

@noindent
The general form of a command call is

@example
@var{cmdname} @var{arg1} @var{arg2} @dots{}
@end example

@noindent
which translates directly to

@example
@var{cmdname} ("@var{arg1}", "@var{arg2}", @dots{})
@end example

Any regular function can be used as a command if it accepts string input
arguments.  For example:

@example
@group
toupper lower_case_arg
   @result{} ans = LOWER_CASE_ARG
@end group
@end example

One difficulty of commands occurs when one of the string input arguments
is stored in a variable.  Because Octave can't tell the difference between
a variable name and an ordinary string, it is not possible to pass a
variable as input to a command.  In such a situation a command must be
called as a function.  For example:

@example
@group
strvar = "hello world";
toupper strvar
   @result{} ans = STRVAR
toupper (strvar)
   @result{} ans = HELLO WORLD
@end group
@end example


@node Organization of Functions
@section Organization of Functions Distributed with Octave

Many of Octave's standard functions are distributed as function files.
They are loosely organized by topic, in subdirectories of
@file{@var{octave-home}/lib/octave/@var{version}/m}, to make it easier
to find them.

The following is a list of all the function file subdirectories, and the
types of functions you will find there.

@table @file
@item audio
Functions for playing and recording sounds.

@item deprecated
Out-of-date functions which will eventually be removed from Octave.

@item elfun
Elementary functions, principally trigonometric.

@item @@ftp
Class functions for the FTP object.

@item general
Miscellaneous matrix manipulations, like @code{flipud}, @code{rot90},
and @code{triu}, as well as other basic functions, like
@code{ismatrix}, @code{narginchk}, etc.

@item geometry
Functions related to Delaunay triangulation.

@item help
Functions for Octave's built-in help system.

@item image
Image processing tools.  These functions require the X Window System.

@item io
Input-output functions.

@item linear-algebra
Functions for linear algebra.

@item miscellaneous
Functions that don't really belong anywhere else.

@item optimization
Functions related to minimization, optimization, and root finding.

@item path
Functions to manage the directory path Octave uses to find functions.

@item pkg
Package manager for installing external packages of functions in Octave.

@item plot
Functions for displaying and printing two- and three-dimensional graphs.

@item polynomial
Functions for manipulating polynomials.

@item prefs
Functions implementing user-defined preferences.

@item set
Functions for creating and manipulating sets of unique values.

@item signal
Functions for signal processing applications.

@item sparse
Functions for handling sparse matrices.

@item specfun
Special functions such as @code{bessel} or @code{factor}.

@item special-matrix
Functions that create special matrix forms such as Hilbert or Vandermonde
matrices.

@item startup
Octave's system-wide startup file.

@item statistics
Statistical functions.

@item strings
Miscellaneous string-handling functions.

@item testfun
Functions for performing unit tests on other functions.

@item time
Functions related to time and date processing.
@end table
