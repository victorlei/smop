# SMOP compiler -- Simple Matlab/Octave to Python compiler
# Copyright 2011-2013 Victor Leikehman

import sys,cPickle,glob,os
import getopt,re
import lexer,parse,resolve,backend,options,node,graphviz

def usage():
    print "SMOP compiler version 0.25"
    print """Usage: smop [options] file-list
    Options:
    -V --version
    -X --exclude=FILES      Ignore files listed in comma-separated list FILES
    -d --dot=REGEX          For functions whose names match REGEX, save debugging
                            information in "dot" format (see www.graphviz.org).
                            You need an installation of graphviz to use --dot
                            option.  Use "dot" utility to create a pdf file.
                            For example: 
                                $ python main.py fastsolver.m -d "solver|cbest"
                                $ dot -Tpdf -o resolve_solver.pdf resolve_solver.dot
    -h --help
    -o --output=FILENAME    By default create file named a.py
    -o- --output=-          Use standard output
    -s --strict             Stop on the first error
    -v --verbose
"""

def main():
    try:
        opts, args = getopt.gnu_getopt(sys.argv[1:],
                                       "d:ho:vVsX:", 
                                       [
                                        "dot=",
                                        "exclude",
                                        "help",
                                        "output=",
                                        "strict",
                                        "verbose",
                                        "version",
                                       ])
    except getopt.GetoptError, err:
        # print help information and exit:
        print str(err) # will print something like "option -a not recognized"
        usage()
        sys.exit(2)

    exclude_list = []
    output = None
    verbose = 0
    strict = 0
    dot = None

    for o, a in opts:
        if o in ("-s", "--strict"):
            strict = 1
        elif o in ("-d", "--dot"):
            dot = re.compile(a)
        elif o in ("-X", "--exclude"):
            exclude_list += a.split(",")
        elif o in ("-v", "--verbose"):
            verbose += 1
        elif o in ("-V", "--version"):
            print "SMOP compiler version 0.25"
            sys.exit()
        elif o in ("-h", "--help"):
            usage()
            sys.exit()
        elif o in ("-o", "--output"):
            output = a
        else:
            assert False, "unhandled option"

    if not output:
        output = "a.py"
    fp = open(output,"w") if output != "-" else sys.stdout
    print >> fp, "# Autogenerated with SMOP version 0.25"
    print >> fp, "# " + " ".join(sys.argv)
    print >> fp, "from __future__ import division"
    print >> fp, "import numpy as np"
    #print >> fp, "from scipy.io import loadmat,savemat"
    #print >> fp, "import os\n"

    #print >> fp, "from copy import copy as _copy"
    #print >> fp, "numpy.random.seed(0)"

    for pattern in args:
        for filename in glob.glob(os.path.expanduser(pattern)):
            if not filename.endswith(".m"):
                print "\tIngored file: '%s'" % filename
                continue
            if os.path.basename(filename) in exclude_list:
                print "\tExcluded file: '%s'" % filename
                continue
            if verbose:
                print filename
            buf = open(filename).read()
            func_list = parse.parse(buf if buf[-1]=='\n' else buf+'\n')

            try:
                symtab = {}
                for func_obj in func_list: 
                    try:
                        func_name = func_obj.head.ident.name
                        symtab[func_name] = func_obj
                        if verbose:
                            print "\t",func_name
                    except AttributeError:
                        if verbose:
                            print "\tJunk ignored"
                        if strict:
                            return
                        continue
                    fp0 = open("parse_"+func_name+".dot","w") if dot and dot.match(func_name) else None
                    if fp0:
                        graphviz.graphviz(func_obj,fp0)
                    if options.do_resolve:
                        resolve.resolve(func_obj)
                        fp0 = open("resolve_"+func_name+".dot","w") if dot and dot.match(func_name) else None
                        if fp0:
                            graphviz.resolve(func_obj,fp0,func_name)

                for func_obj in func_list:
                    s = backend.backend(func_obj)
                    print >> fp, s
            except Exception as ex:
                print repr(ex)
                if strict:
                    return


if __name__ == "__main__":
    main()
